#!/bin/sh
"exec" "/Volumes/source/jj-stack/.venv/bin/python3" "$0" "$@"
"""
jj-stack: Automate pushing stacks of Jujutsu changes to GitHub as pull requests.

This tool manages bookmark creation, PR relationships, cross-references, and handles
stack updates over time. It is stateless and queries JJ and GitHub each time to
determine the current state.
"""

import argparse
import json
import re
import subprocess
import sys
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple

try:
    from rich.console import Console, Group
    from rich.live import Live
    from rich.spinner import Spinner
    from rich.table import Table
    from rich.text import Text
except ImportError:
    print("Error: 'rich' package is required. Install it with: pip install rich", file=sys.stderr)
    sys.exit(1)


# ============================================================================
# Global Configuration
# ============================================================================

VERBOSE = False
GITHUB_OPERATION_COUNTS = defaultdict(int)


# ============================================================================
# Data Models
# ============================================================================

@dataclass
class Change:
    """Represents a JJ change in the stack."""
    change_id: str
    commit_id: str
    description: str

    @property
    def title(self) -> str:
        """First line of description."""
        return self.description.split('\n')[0]


# ============================================================================
# Progress Display
# ============================================================================

class PushProgress:
    """Multi-line status board for push operations, rendered to stderr."""

    WAITING = "waiting"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"

    def __init__(self, changes: List[Change]):
        self.changes = changes
        self.console = Console(file=sys.stderr)
        self.statuses: Dict[str, Tuple[str, str]] = {}
        for c in changes:
            self.statuses[c.change_id] = (self.WAITING, "Waiting")
        self._live: Optional[Live] = None

    def _build_display(self):
        """Build the Rich renderable for the current state."""
        table = Table(
            show_header=False,
            box=None,
            padding=(0, 1),
            pad_edge=False,
        )
        table.add_column("icon", width=2, no_wrap=True)
        table.add_column("change", style="dim", no_wrap=True)
        table.add_column("title", max_width=40, no_wrap=True, overflow="ellipsis")
        table.add_column("status")

        for change in self.changes:
            state, message = self.statuses[change.change_id]

            if state == self.WAITING:
                icon = Text("  ", style="dim")
                status_text = Text(message, style="dim")
            elif state == self.IN_PROGRESS:
                icon = Spinner("dots")
                status_text = Text(message, style="yellow")
            elif state == self.SUCCESS:
                icon = Text("✓", style="green")
                status_text = Text(message)
            else:
                icon = Text("✗", style="red")
                status_text = Text(message, style="red")

            table.add_row(
                icon,
                Text(change.change_id),
                Text(change.title),
                status_text,
            )

        header = Text(f"Pushing {len(self.changes)} changes\n", style="bold")
        return Group(header, table)

    def update(self, change_id: str, state: str, message: str):
        """Update a change's status and refresh the display."""
        self.statuses[change_id] = (state, message)
        if self._live:
            self._live.update(self._build_display())

    def __enter__(self):
        self._live = Live(
            self._build_display(),
            console=self.console,
            refresh_per_second=10,
        )
        self._live.__enter__()
        return self

    def __exit__(self, *args):
        if self._live:
            return self._live.__exit__(*args)


# ============================================================================
# Command Execution Utilities
# ============================================================================

def run(cmd: List[str], check: bool = True, capture: bool = True) -> subprocess.CompletedProcess:
    """Execute a command and return the result."""
    if VERBOSE:
        if cmd[0] == 'gh':
            operation_key = ' '.join(cmd[:3]) if len(cmd) >= 3 else ' '.join(cmd)
            GITHUB_OPERATION_COUNTS[operation_key] += 1
            print(f"[GitHub API] {operation_key}", file=sys.stderr)
        print(f"[VERBOSE] Running: {' '.join(cmd)}", file=sys.stderr)

    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=capture,
            text=True
        )
        if VERBOSE and result.returncode == 0:
            print(f"[VERBOSE] Command succeeded", file=sys.stderr)
        return result
    except subprocess.CalledProcessError as e:
        if check:
            print(f"Error executing command: {' '.join(cmd)}", file=sys.stderr)
            print(f"Exit code: {e.returncode}", file=sys.stderr)
            if e.stderr:
                print(f"Stderr: {e.stderr}", file=sys.stderr)
            sys.exit(1)
        raise


def check_prerequisites():
    """Verify that required tools are available."""
    # Check for jj
    try:
        run(['jj', '--version'], capture=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("Error: jj (Jujutsu) is not available. Please install it first.", file=sys.stderr)
        sys.exit(1)

    # Check for gh
    try:
        run(['gh', '--version'], capture=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("Error: gh (GitHub CLI) is not available. Please install it first.", file=sys.stderr)
        sys.exit(1)

    # Check gh authentication
    result = run(['gh', 'auth', 'status'], check=False)
    if result.returncode != 0:
        print("Error: GitHub CLI is not authenticated. Run 'gh auth login' first.", file=sys.stderr)
        sys.exit(1)

    # Check if we're in a JJ repo
    result = run(['jj', 'root'], check=False)
    if result.returncode != 0:
        print("Error: Not in a Jujutsu repository.", file=sys.stderr)
        sys.exit(1)


# ============================================================================
# GitHub Integration
# ============================================================================

def get_github_username() -> str:
    """Get the authenticated GitHub username."""
    result = run(['gh', 'api', 'user', '-q', '.login'])
    username = result.stdout.strip()
    if not username:
        print("Error: Could not determine GitHub username.", file=sys.stderr)
        sys.exit(1)
    if VERBOSE:
        print(f"[VERBOSE] GitHub username: {username}", file=sys.stderr)
    return username


def find_pr_for_change(change_id: str, username: str, state: str = 'open') -> Optional[int]:
    """Find existing PR for a change by querying GitHub.

    Args:
        change_id: The JJ change ID to search for
        username: The GitHub username
        state: PR state to filter by ('open', 'closed', 'merged', 'all')

    Returns PR number if found, None otherwise.
    """
    try:
        result = run([
            'gh', 'pr', 'list',
            '--json', 'number,headRefName',
            '--state', state
        ])

        prs = json.loads(result.stdout)

        # Look for PR whose head branch starts with username and ends with this change ID
        for pr in prs:
            if pr['headRefName'].startswith(f"{username}/") and pr['headRefName'].endswith(f"-{change_id}"):
                return pr['number']

        return None
    except Exception as e:
        print(f"Warning: Error finding PR for change {change_id}: {e}", file=sys.stderr)
        return None


def fetch_prs_batch(username: str, state: str = 'open') -> Dict[str, int]:
    """Fetch all PRs in one call and build change_id to PR number mapping.

    Args:
        username: The GitHub username
        state: PR state to filter by ('open', 'closed', 'merged', 'all')

    Returns:
        Dictionary mapping change_id -> PR number
    """
    try:
        if VERBOSE:
            print(f"[VERBOSE] Fetching PRs with state={state}", file=sys.stderr)

        result = run([
            'gh', 'pr', 'list',
            '--json', 'number,headRefName',
            '--state', state
        ])

        prs = json.loads(result.stdout)

        # Build mapping: extract change_id from branch names
        mapping = {}
        for pr in prs:
            head = pr['headRefName']
            # Branch format: username/date/slug-change_id
            if head.startswith(f"{username}/") and '-' in head:
                change_id = head.split('-')[-1]
                mapping[change_id] = pr['number']

        if VERBOSE:
            print(f"[VERBOSE] Found {len(mapping)} PR(s) matching pattern", file=sys.stderr)

        return mapping
    except Exception as e:
        print(f"Warning: Error fetching PRs: {e}", file=sys.stderr)
        return {}


def extract_change_id_from_bookmark(bookmark: str) -> Optional[str]:
    """Extract change_id from bookmark name.

    Bookmark format: username/date/slug-change_id
    Returns the change_id (last component after final dash).
    """
    if '-' in bookmark:
        return bookmark.split('-')[-1]
    return None


def get_pr_info(pr_number: int) -> Dict:
    """Get detailed information about a PR."""
    result = run([
        'gh', 'pr', 'view', str(pr_number),
        '--json', 'number,title,state,headRefName,baseRefName,body,url'
    ])
    return json.loads(result.stdout)


def get_pr_state(pr_number: int) -> str:
    """Get the state of a PR (OPEN, MERGED, CLOSED)."""
    try:
        info = get_pr_info(pr_number)
        return info['state']
    except Exception:
        return 'UNKNOWN'


# ============================================================================
# JJ Integration
# ============================================================================

def get_stack_changes() -> List[Change]:
    """Query JJ for all changes in the current stack.

    Returns changes in topological order from trunk to @.
    """
    if VERBOSE:
        print(f"[VERBOSE] Querying jj for stack changes (trunk()..@)", file=sys.stderr)

    template = r'change_id.short() ++ "\n" ++ commit_id.short() ++ "\n" ++ description ++ "\x00"'

    result = run([
        'jj', 'log',
        '-r', 'trunk()..@',
        '--reversed',
        '--no-graph',
        '-T', template
    ])

    changes = []
    for entry in result.stdout.split('\x00'):
        entry = entry.strip()
        if not entry:
            continue

        lines = entry.split('\n', 2)
        if len(lines) < 3:
            continue

        change_id = lines[0].strip()
        commit_id = lines[1].strip()
        description = lines[2].strip()

        changes.append(Change(
            change_id=change_id,
            commit_id=commit_id,
            description=description
        ))

    if VERBOSE:
        print(f"[VERBOSE] Found {len(changes)} change(s) in stack", file=sys.stderr)

    return changes


def get_parent_change_id(change_id: str) -> Optional[str]:
    """Get the parent change ID for a given change.

    Returns None if the parent is trunk.
    """
    result = run([
        'jj', 'log',
        '-r', f'{change_id}-',
        '--no-graph',
        '-T', 'change_id.short()'
    ])

    parent_id = result.stdout.strip()

    # Check if parent is trunk
    trunk_result = run([
        'jj', 'log',
        '-r', 'trunk()',
        '--no-graph',
        '-T', 'change_id.short()'
    ])
    trunk_id = trunk_result.stdout.strip()

    if parent_id == trunk_id:
        return None

    return parent_id


def get_bookmarks_for_change(change_id: str) -> List[str]:
    """Get all bookmarks pointing to a change."""
    result = run([
        'jj', 'log',
        '-r', change_id,
        '--no-graph',
        '-T', 'bookmarks'
    ])

    output = result.stdout.strip()
    if not output or output == '(empty)':
        return []

    # Parse bookmark list (format: "bookmark1 bookmark2 bookmark3")
    return [b.strip() for b in output.split() if b.strip()]


def bookmark_exists(bookmark: str) -> bool:
    """Check if a bookmark exists."""
    result = run(['jj', 'bookmark', 'list'], check=True)
    for line in result.stdout.split('\n'):
        if line.strip().startswith(bookmark + ':') or line.strip().startswith(bookmark + ' '):
            return True
    return False


# ============================================================================
# Bookmark Management
# ============================================================================

def generate_slug(description: str) -> str:
    """Generate a URL-friendly slug from the first line of description.

    Example: "Fix authentication bug" -> "fix-auth-bug"
    """
    title = description.split('\n')[0]

    # Convert to lowercase
    slug = title.lower()

    # Remove special characters, keep alphanumeric and spaces
    slug = re.sub(r'[^a-z0-9\s-]', '', slug)

    # Replace spaces and multiple hyphens with single hyphen
    slug = re.sub(r'[-\s]+', '-', slug)

    # Trim hyphens from ends
    slug = slug.strip('-')

    # Limit length (take first 5 words max)
    words = slug.split('-')[:5]
    slug = '-'.join(words)

    return slug or 'change'


def generate_bookmark_name(change: Change, username: str, date: str) -> str:
    """Generate bookmark name: username/date/slug-change_id."""
    slug = generate_slug(change.description)
    return f"{username}/{date}/{slug}-{change.change_id}"


def ensure_bookmark(change: Change, username: str, date: str) -> str:
    """Create bookmark if it doesn't exist, return bookmark name.

    If bookmark exists but points to different commit, move it to current commit.
    Also ensures the bookmark is tracked with the remote.
    """
    bookmark = generate_bookmark_name(change, username, date)

    if bookmark_exists(bookmark):
        if VERBOSE:
            print(f"[VERBOSE] Updating existing bookmark: {bookmark}", file=sys.stderr)
        # Move bookmark to current commit for this change (in case it's moved)
        run(['jj', 'bookmark', 'set', bookmark, '-r', change.change_id, '-B'])
    else:
        if VERBOSE:
            print(f"[VERBOSE] Creating new bookmark: {bookmark}", file=sys.stderr)
        # Create new bookmark
        run(['jj', 'bookmark', 'create', bookmark, '-r', change.change_id])
        # Track bookmark with remote
        run(['jj', 'bookmark', 'track', bookmark, '--remote=origin'])

    return bookmark


# ============================================================================
# PR Operations
# ============================================================================

def format_pr_description(
    change: Change,
    all_changes: List[Change],
    username: str,
    change_to_pr: Dict[str, int]
) -> str:
    """Format PR description with stack information and cross-references."""
    description = change.description

    # Build stack information section
    stack_info = ["\n---\n", "**Stack Information:**"]

    # Find position in stack
    position = next((i + 1 for i, c in enumerate(all_changes) if c.change_id == change.change_id), 0)
    stack_info.append(f"- **Stack Position:** {position} of {len(all_changes)}")

    # Find all ancestor PRs (from trunk to current, excluding current)
    ancestor_prs = []
    current_id = change.change_id
    while True:
        parent_id = get_parent_change_id(current_id)
        if not parent_id:
            break
        if parent_id in change_to_pr:
            parent_change = next((c for c in all_changes if c.change_id == parent_id), None)
            if parent_change:
                ancestor_prs.append((change_to_pr[parent_id], parent_change.title))
        current_id = parent_id

    # Reverse so it goes from bottom to top
    ancestor_prs.reverse()

    # Find all descendant PRs (from current to top of stack, excluding current)
    descendant_prs = []
    for c in all_changes:
        # Check if this change is a descendant
        current_id = c.change_id
        while True:
            parent_id = get_parent_change_id(current_id)
            if not parent_id:
                break
            if parent_id == change.change_id:
                # This change is a descendant
                if c.change_id in change_to_pr:
                    descendant_prs.append((change_to_pr[c.change_id], c.title))
                break
            current_id = parent_id

    # List all PRs in stack (reversed order: top to bottom)
    if ancestor_prs or descendant_prs:
        stack_info.append("\n**Stack:**")

        # Show descendants (reversed, so furthest descendant first)
        for pr_num, title in reversed(descendant_prs):
            stack_info.append(f"- #{pr_num}")

        # Show current (this PR)
        if change.change_id in change_to_pr:
            stack_info.append(f"- **→ #{change_to_pr[change.change_id]}** (this PR)")
        else:
            stack_info.append(f"- **→ {change.title}** (this PR)")

        # Show ancestors (reversed, so immediate parent first)
        for pr_num, title in reversed(ancestor_prs):
            stack_info.append(f"- #{pr_num}")

    stack_info.append(f"\n**JJ Change ID:** `{change.change_id}`")
    stack_info.append("\n---")
    stack_info.append("_This PR is part of a stack managed by jj-stack._")

    return description + '\n'.join(stack_info)


def create_pr(
    bookmark: str,
    change: Change,
    base_branch: str,
    all_changes: List[Change],
    username: str,
    change_to_pr: Dict[str, int]
) -> int:
    """Create GitHub PR for change.

    Returns PR number.
    """
    if VERBOSE:
        print(f"[VERBOSE] Creating PR: {change.title} (base: {base_branch})", file=sys.stderr)

    title = change.title
    body = format_pr_description(change, all_changes, username, change_to_pr)

    result = run([
        'gh', 'pr', 'create',
        '-B', base_branch,
        '-H', bookmark,
        '-t', title,
        '-b', body
    ])

    # Extract PR number from output
    # Output format: "https://github.com/owner/repo/pull/123"
    match = re.search(r'/pull/(\d+)', result.stdout)
    if match:
        return int(match.group(1))

    # Fallback: query for PR by head branch
    pr_num = find_pr_for_change(change.change_id, username)
    if pr_num:
        return pr_num

    print(f"Warning: Could not determine PR number for {bookmark}", file=sys.stderr)
    return 0


def update_pr(
    pr_number: int,
    change: Change,
    base_branch: str,
    all_changes: List[Change],
    username: str,
    change_to_pr: Dict[str, int]
):
    """Update existing PR (title, base branch, and description)."""
    if VERBOSE:
        print(f"[VERBOSE] Updating PR #{pr_number}: {change.title} (base: {base_branch})", file=sys.stderr)

    title = change.title
    body = format_pr_description(change, all_changes, username, change_to_pr)

    # Update title, base branch, and body in one call
    run([
        'gh', 'pr', 'edit', str(pr_number),
        '--title', title,
        '--base', base_branch,
        '--body', body
    ], check=False)


# ============================================================================
# Commands
# ============================================================================

def _cmd_push_verbose(changes, username, date, change_to_bookmark):
    """Push with scrolling text output (verbose mode)."""
    print(f"Found {len(changes)} change(s) in stack")

    # First pass: create bookmarks and push them
    print("\nCreating bookmarks and pushing to GitHub...")
    for change in changes:
        bookmark = ensure_bookmark(change, username, date)
        change_to_bookmark[change.change_id] = bookmark
        print(f"  {change.change_id}: {bookmark}")

        if VERBOSE:
            print(f"[VERBOSE] Pushing bookmark: {bookmark}", file=sys.stderr)
        result = run(['jj', 'git', 'push', '--bookmark', bookmark], check=False)
        if result.returncode != 0:
            print(f"Warning: Failed to push bookmark {bookmark}", file=sys.stderr)

    # Second pass: create or update PRs
    print("\nCreating/updating PRs...")

    if VERBOSE:
        print(f"[VERBOSE] Fetching existing PRs for user: {username}", file=sys.stderr)
    change_to_pr = fetch_prs_batch(username, state='open')

    newly_created = []
    for change in changes:
        bookmark = change_to_bookmark[change.change_id]

        if VERBOSE:
            print(f"[VERBOSE] Determining base branch for {change.change_id}", file=sys.stderr)
        parent_id = get_parent_change_id(change.change_id)
        if parent_id and parent_id in change_to_bookmark:
            base_branch = change_to_bookmark[parent_id]
        else:
            base_branch = "master"

        if VERBOSE:
            print(f"[VERBOSE] Base branch for {change.change_id}: {base_branch}", file=sys.stderr)

        pr_number = change_to_pr.get(change.change_id)

        if not pr_number:
            try:
                pr_number = create_pr(bookmark, change, base_branch, changes, username, change_to_pr)
                if pr_number:
                    change_to_pr[change.change_id] = pr_number
                    newly_created.append(change.change_id)
                    print(f"  ✓ Created PR #{pr_number}: {change.title}")
            except Exception as e:
                print(f"  ✗ Failed to create PR for {change.change_id}: {e}", file=sys.stderr)
        else:
            try:
                update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                print(f"  ✓ Updated PR #{pr_number}: {change.title}")
            except Exception as e:
                print(f"  ✗ Failed to update PR #{pr_number}: {e}", file=sys.stderr)

    # Third pass: update cross-references for newly created PRs
    if newly_created:
        print("\nUpdating PR cross-references...")
        for change in changes:
            if change.change_id in newly_created:
                pr_number = change_to_pr.get(change.change_id)
                if pr_number:
                    parent_id = get_parent_change_id(change.change_id)
                    if parent_id and parent_id in change_to_bookmark:
                        base_branch = change_to_bookmark[parent_id]
                    else:
                        base_branch = "master"

                    try:
                        update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                        print(f"  ✓ Updated PR #{pr_number} with full cross-references")
                    except Exception as e:
                        print(f"  ✗ Failed to update PR #{pr_number}: {e}", file=sys.stderr)

    print(f"\nStack pushed successfully! ({len(changes)} changes)")

    if VERBOSE:
        print("\n" + "=" * 60, file=sys.stderr)
        print("GitHub API Operation Statistics:", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        total_operations = 0
        for operation, count in sorted(GITHUB_OPERATION_COUNTS.items()):
            print(f"  {operation}: {count}", file=sys.stderr)
            total_operations += count
        print("-" * 60, file=sys.stderr)
        print(f"  Total GitHub API operations: {total_operations}", file=sys.stderr)
        print("=" * 60, file=sys.stderr)


def _cmd_push_progress(changes, username, date, change_to_bookmark):
    """Push with Rich progress board on stderr."""
    with PushProgress(changes) as progress:
        # Pass 1: create bookmarks and push them
        for change in changes:
            progress.update(change.change_id, PushProgress.IN_PROGRESS, "Creating bookmark...")
            bookmark = ensure_bookmark(change, username, date)
            change_to_bookmark[change.change_id] = bookmark

            progress.update(change.change_id, PushProgress.IN_PROGRESS, "Pushing bookmark...")
            result = run(['jj', 'git', 'push', '--bookmark', bookmark], check=False)
            if result.returncode != 0:
                progress.update(change.change_id, PushProgress.FAILED, "Push failed")
            else:
                progress.update(change.change_id, PushProgress.SUCCESS, "Pushed")

        # Pass 2: create or update PRs
        progress.update(changes[0].change_id, PushProgress.IN_PROGRESS, "Fetching existing PRs...")
        change_to_pr = fetch_prs_batch(username, state='open')

        newly_created = []
        for change in changes:
            bookmark = change_to_bookmark[change.change_id]
            parent_id = get_parent_change_id(change.change_id)
            if parent_id and parent_id in change_to_bookmark:
                base_branch = change_to_bookmark[parent_id]
            else:
                base_branch = "master"

            pr_number = change_to_pr.get(change.change_id)

            if not pr_number:
                progress.update(change.change_id, PushProgress.IN_PROGRESS, "Creating PR...")
                try:
                    pr_number = create_pr(bookmark, change, base_branch, changes, username, change_to_pr)
                    if pr_number:
                        change_to_pr[change.change_id] = pr_number
                        newly_created.append(change.change_id)
                        progress.update(change.change_id, PushProgress.SUCCESS, f"Created PR #{pr_number}")
                except Exception:
                    progress.update(change.change_id, PushProgress.FAILED, "PR creation failed")
            else:
                progress.update(change.change_id, PushProgress.IN_PROGRESS, f"Updating PR #{pr_number}...")
                try:
                    update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                    progress.update(change.change_id, PushProgress.SUCCESS, f"Updated PR #{pr_number}")
                except Exception:
                    progress.update(change.change_id, PushProgress.FAILED, "PR update failed")

        # Pass 3: update cross-references for newly created PRs
        if newly_created:
            for change in changes:
                if change.change_id in newly_created:
                    pr_number = change_to_pr.get(change.change_id)
                    if pr_number:
                        parent_id = get_parent_change_id(change.change_id)
                        if parent_id and parent_id in change_to_bookmark:
                            base_branch = change_to_bookmark[parent_id]
                        else:
                            base_branch = "master"

                        progress.update(change.change_id, PushProgress.IN_PROGRESS, "Updating cross-refs...")
                        try:
                            update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                            progress.update(change.change_id, PushProgress.SUCCESS, f"PR #{pr_number} ready")
                        except Exception:
                            progress.update(change.change_id, PushProgress.FAILED, "Cross-ref update failed")

    print(f"\nStack pushed successfully! ({len(changes)} changes)")


def cmd_push(args):
    """Push entire stack to GitHub, creating/updating PRs."""
    if VERBOSE:
        print(f"[VERBOSE] Getting GitHub username", file=sys.stderr)
    username = get_github_username()

    if VERBOSE:
        print(f"[VERBOSE] Getting stack changes", file=sys.stderr)
    changes = get_stack_changes()

    if not changes:
        print("No changes in stack.")
        return

    date = datetime.now().strftime('%Y-%m-%d')
    change_to_bookmark = {}

    if VERBOSE:
        _cmd_push_verbose(changes, username, date, change_to_bookmark)
    else:
        _cmd_push_progress(changes, username, date, change_to_bookmark)


def cmd_status(args):
    """Display status of current stack and PRs."""
    username = get_github_username()
    changes = get_stack_changes()

    print(f"Current Stack Status (GitHub user: {username})")
    print("=" * 60)

    if not changes:
        print("\nNo changes in stack.")
        return

    # Fetch all PRs once
    change_to_pr = fetch_prs_batch(username, state='open')

    for i, change in enumerate(changes, 1):
        print(f"\n{i}. {change.title}")
        print(f"   Change ID: {change.change_id}")

        # Find bookmark for this change
        bookmarks = get_bookmarks_for_change(change.change_id)
        user_bookmarks = [b for b in bookmarks if b.startswith(f"{username}/")]
        if user_bookmarks:
            print(f"   Bookmark: {user_bookmarks[0]}")
        else:
            print(f"   Bookmark: Not created yet")

        # Find PR for this change
        pr_number = change_to_pr.get(change.change_id)

        if pr_number:
            try:
                pr_info = get_pr_info(pr_number)
                print(f"   PR: #{pr_number} ({pr_info['state']})")
                print(f"   URL: {pr_info['url']}")
            except Exception as e:
                print(f"   PR: #{pr_number} (error getting details: {e})")
        else:
            print(f"   PR: Not created yet")

    print("\n" + "=" * 60)
    print(f"Total: {len(changes)} change(s)")


def cmd_sync(args):
    """Sync stack with latest trunk and update PRs."""
    if VERBOSE:
        print(f"[VERBOSE] Getting GitHub username", file=sys.stderr)
    username = get_github_username()

    # 1. Fetch latest trunk
    print("Fetching latest trunk...")
    if VERBOSE:
        print(f"[VERBOSE] Running git fetch", file=sys.stderr)
    run(['jj', 'git', 'fetch'])

    # 2. Rebase stack
    print("Rebasing stack...")
    if VERBOSE:
        print(f"[VERBOSE] Rebasing onto trunk()", file=sys.stderr)
    result = run(['jj', 'rebase', '-d', 'trunk()'], check=False)
    if result.returncode != 0:
        print("Error: Rebase failed. Resolve conflicts and run sync again.", file=sys.stderr)
        sys.exit(1)

    # 3. Get all changes
    if VERBOSE:
        print(f"[VERBOSE] Getting stack changes after rebase", file=sys.stderr)
    changes = get_stack_changes()

    if not changes:
        print("No changes in stack.")
        return

    # 4. Update bookmarks to point to rebased commits
    print("Updating bookmarks...")
    for change in changes:
        bookmarks = get_bookmarks_for_change(change.change_id)
        for bookmark in bookmarks:
            if bookmark.startswith(f"{username}/"):
                if VERBOSE:
                    print(f"[VERBOSE] Updating bookmark {bookmark} to point to {change.change_id}", file=sys.stderr)
                # Move bookmark to current commit for this change
                run(['jj', 'bookmark', 'set', bookmark, '-r', change.change_id, '-B'])

    # 5. Force-push updated bookmarks
    print("Force-pushing updated bookmarks...")
    for change in changes:
        bookmarks = get_bookmarks_for_change(change.change_id)
        for bookmark in bookmarks:
            if bookmark.startswith(f"{username}/"):
                if VERBOSE:
                    print(f"[VERBOSE] Force-pushing bookmark: {bookmark}", file=sys.stderr)
                result = run(['jj', 'git', 'push', '--bookmark', bookmark], check=False)
                if result.returncode != 0:
                    print(f"Warning: Failed to push bookmark {bookmark}", file=sys.stderr)

    # 6. Update PRs
    print("Updating PRs...")

    date = datetime.now().strftime('%Y-%m-%d')
    change_to_bookmark = {}

    # Build bookmark mapping
    for change in changes:
        bookmarks = get_bookmarks_for_change(change.change_id)
        for bookmark in bookmarks:
            if bookmark.startswith(f"{username}/"):
                change_to_bookmark[change.change_id] = bookmark
                break

    # Fetch all PRs once (single batch call)
    change_to_pr = fetch_prs_batch(username, state='open')

    # Update each PR
    for change in changes:
        pr_number = change_to_pr.get(change.change_id)
        if pr_number:
            # Determine correct base branch
            parent_id = get_parent_change_id(change.change_id)
            if parent_id and parent_id in change_to_bookmark:
                base_branch = change_to_bookmark[parent_id]
            else:
                base_branch = "master"

            try:
                update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                print(f"  ✓ Updated PR #{pr_number}")
            except Exception as e:
                print(f"  ✗ Failed to update PR #{pr_number}: {e}", file=sys.stderr)

    print("\nStack synced successfully!")


def cmd_cleanup(args):
    """Remove bookmarks for merged/closed PRs."""
    if VERBOSE:
        print(f"[VERBOSE] Getting GitHub username", file=sys.stderr)
    username = get_github_username()

    # Get all bookmarks matching our pattern
    if VERBOSE:
        print(f"[VERBOSE] Listing bookmarks", file=sys.stderr)
    result = run(['jj', 'bookmark', 'list'])
    bookmarks = []
    for line in result.stdout.split('\n'):
        line = line.strip()
        if not line:
            continue
        # Parse bookmark name (format: "bookmark: commit_id")
        parts = line.split(':', 1)
        if parts and parts[0].strip().startswith(f"{username}/"):
            bookmark = parts[0].strip()
            bookmarks.append(bookmark)

    if not bookmarks:
        print(f"No bookmarks found for user {username}")
        return

    print(f"Found {len(bookmarks)} bookmark(s) for {username}")

    # Fetch all PRs once (including all states)
    if VERBOSE:
        print(f"[VERBOSE] Fetching all PRs for user: {username}", file=sys.stderr)
    change_to_pr = fetch_prs_batch(username, state='all')

    cleaned = 0
    for bookmark in bookmarks:
        # Extract change ID from bookmark name
        change_id = extract_change_id_from_bookmark(bookmark)
        if not change_id:
            if VERBOSE:
                print(f"[VERBOSE] Could not extract change ID from bookmark: {bookmark}", file=sys.stderr)
            continue

        # Lookup PR from batch results
        pr_number = change_to_pr.get(change_id)

        if pr_number:
            if VERBOSE:
                print(f"[VERBOSE] Checking PR state for #{pr_number}", file=sys.stderr)
            pr_state = get_pr_state(pr_number)

            if pr_state in ['MERGED', 'CLOSED']:
                print(f"Cleaning up bookmark {bookmark} (PR #{pr_number} is {pr_state})")

                if VERBOSE:
                    print(f"[VERBOSE] Deleting bookmark locally: {bookmark}", file=sys.stderr)
                # Delete bookmark locally
                run(['jj', 'bookmark', 'delete', bookmark])

                cleaned += 1
        else:
            if VERBOSE:
                print(f"[VERBOSE] No PR found for change {change_id}", file=sys.stderr)

    # Push all deletions to remote in one command
    if cleaned > 0:
        print("Pushing bookmark deletions to remote...")
        if VERBOSE:
            print(f"[VERBOSE] Pushing deleted bookmarks", file=sys.stderr)
        run(['jj', 'git', 'push', '--deleted'], check=False)

    print(f"\nCleaned up {cleaned} bookmark(s)")


def cmd_list(args):
    """List all changes in current stack with metadata."""
    changes = get_stack_changes()

    if not changes:
        print("No changes in stack.")
        return

    print(f"Stack Changes (trunk()..@):")
    print("=" * 60)

    for i, change in enumerate(changes, 1):
        print(f"\n{i}. {change.title}")
        print(f"   Change ID: {change.change_id}")
        print(f"   Commit ID: {change.commit_id}")

        parent_id = get_parent_change_id(change.change_id)
        if parent_id:
            print(f"   Parent: {parent_id}")
        else:
            print(f"   Parent: trunk")

        bookmarks = get_bookmarks_for_change(change.change_id)
        if bookmarks:
            print(f"   Bookmarks: {', '.join(bookmarks)}")

    print("\n" + "=" * 60)
    print(f"Total: {len(changes)} change(s)")


# ============================================================================
# Main
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Automate pushing stacks of Jujutsu changes to GitHub as pull requests."
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Print each operation as it is performed'
    )

    subparsers = parser.add_subparsers(dest='command', help='Subcommands')

    # push command
    push_parser = subparsers.add_parser(
        'push',
        help='Push current stack to GitHub, creating/updating PRs'
    )

    # status command
    status_parser = subparsers.add_parser(
        'status',
        help='Show status of current stack and associated PRs'
    )

    # sync command
    sync_parser = subparsers.add_parser(
        'sync',
        help='Fetch latest trunk, rebase stack, update PRs'
    )

    # list command
    list_parser = subparsers.add_parser(
        'list',
        help='List all changes in current stack with metadata'
    )

    # cleanup command
    cleanup_parser = subparsers.add_parser(
        'cleanup',
        help='Remove bookmarks for merged/closed PRs'
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Set global verbose flag
    global VERBOSE
    VERBOSE = args.verbose

    # Check prerequisites
    check_prerequisites()

    # Dispatch to command handler
    if args.command == 'push':
        cmd_push(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'sync':
        cmd_sync(args)
    elif args.command == 'list':
        cmd_list(args)
    elif args.command == 'cleanup':
        cmd_cleanup(args)
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == '__main__':
    main()
