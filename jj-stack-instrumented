#!/usr/bin/env python3
"""
jj-stack: Automate pushing stacks of Jujutsu changes to GitHub as pull requests.

This tool manages bookmark creation, PR relationships, cross-references, and handles
stack updates over time. It is stateless and queries JJ and GitHub each time to
determine the current state.
"""

import argparse
import json
import re
import subprocess
import sys
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple


# ============================================================================
# GitHub API Operation Tracking
# ============================================================================

# Global counter for tracking GitHub operations
GITHUB_OPERATION_COUNTS = defaultdict(int)


# ============================================================================
# Data Models
# ============================================================================

@dataclass
class Change:
    """Represents a JJ change in the stack."""
    change_id: str
    commit_id: str
    description: str

    @property
    def title(self) -> str:
        """First line of description."""
        return self.description.split('\n')[0]


# ============================================================================
# Command Execution Utilities
# ============================================================================

def run(cmd: List[str], check: bool = True, capture: bool = True) -> subprocess.CompletedProcess:
    """Execute a command and return the result."""
    # Track GitHub operations
    if cmd[0] == 'gh':
        operation_key = ' '.join(cmd[:3]) if len(cmd) >= 3 else ' '.join(cmd)
        GITHUB_OPERATION_COUNTS[operation_key] += 1
        print(f"[GitHub API] {operation_key}", file=sys.stderr)

    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=capture,
            text=True
        )
        return result
    except subprocess.CalledProcessError as e:
        if check:
            print(f"Error executing command: {' '.join(cmd)}", file=sys.stderr)
            print(f"Exit code: {e.returncode}", file=sys.stderr)
            if e.stderr:
                print(f"Stderr: {e.stderr}", file=sys.stderr)
            sys.exit(1)
        raise


def check_prerequisites():
    """Verify that required tools are available."""
    # Check for jj
    try:
        run(['jj', '--version'], capture=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("Error: jj (Jujutsu) is not available. Please install it first.", file=sys.stderr)
        sys.exit(1)

    # Check for gh
    try:
        run(['gh', '--version'], capture=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("Error: gh (GitHub CLI) is not available. Please install it first.", file=sys.stderr)
        sys.exit(1)

    # Check gh authentication
    result = run(['gh', 'auth', 'status'], check=False)
    if result.returncode != 0:
        print("Error: GitHub CLI is not authenticated. Run 'gh auth login' first.", file=sys.stderr)
        sys.exit(1)

    # Check if we're in a JJ repo
    result = run(['jj', 'root'], check=False)
    if result.returncode != 0:
        print("Error: Not in a Jujutsu repository.", file=sys.stderr)
        sys.exit(1)


# ============================================================================
# GitHub Integration
# ============================================================================

def get_github_username() -> str:
    """Get the authenticated GitHub username."""
    result = run(['gh', 'api', 'user', '-q', '.login'])
    username = result.stdout.strip()
    if not username:
        print("Error: Could not determine GitHub username.", file=sys.stderr)
        sys.exit(1)
    return username


def find_pr_for_change(change_id: str, username: str, state: str = 'open') -> Optional[int]:
    """Find existing PR for a change by querying GitHub.

    Args:
        change_id: The JJ change ID to search for
        username: The GitHub username
        state: PR state to filter by ('open', 'closed', 'merged', 'all')

    Returns PR number if found, None otherwise.
    """
    try:
        result = run([
            'gh', 'pr', 'list',
            '--json', 'number,headRefName',
            '--state', state
        ])

        prs = json.loads(result.stdout)

        # Look for PR whose head branch starts with username and ends with this change ID
        for pr in prs:
            if pr['headRefName'].startswith(f"{username}/") and pr['headRefName'].endswith(f"-{change_id}"):
                return pr['number']

        return None
    except Exception as e:
        print(f"Warning: Error finding PR for change {change_id}: {e}", file=sys.stderr)
        return None


def get_pr_info(pr_number: int) -> Dict:
    """Get detailed information about a PR."""
    result = run([
        'gh', 'pr', 'view', str(pr_number),
        '--json', 'number,title,state,headRefName,baseRefName,body,url'
    ])
    return json.loads(result.stdout)


def get_pr_state(pr_number: int) -> str:
    """Get the state of a PR (OPEN, MERGED, CLOSED)."""
    try:
        info = get_pr_info(pr_number)
        return info['state']
    except Exception:
        return 'UNKNOWN'


# ============================================================================
# JJ Integration
# ============================================================================

def get_stack_changes() -> List[Change]:
    """Query JJ for all changes in the current stack.

    Returns changes in topological order from trunk to @.
    """
    template = r'change_id.short() ++ "\n" ++ commit_id.short() ++ "\n" ++ description ++ "\x00"'

    result = run([
        'jj', 'log',
        '-r', 'trunk()..@',
        '--reversed',
        '--no-graph',
        '-T', template
    ])

    changes = []
    for entry in result.stdout.split('\x00'):
        entry = entry.strip()
        if not entry:
            continue

        lines = entry.split('\n', 2)
        if len(lines) < 3:
            continue

        change_id = lines[0].strip()
        commit_id = lines[1].strip()
        description = lines[2].strip()

        changes.append(Change(
            change_id=change_id,
            commit_id=commit_id,
            description=description
        ))

    return changes


def get_parent_change_id(change_id: str) -> Optional[str]:
    """Get the parent change ID for a given change.

    Returns None if the parent is trunk.
    """
    result = run([
        'jj', 'log',
        '-r', f'{change_id}-',
        '--no-graph',
        '-T', 'change_id.short()'
    ])

    parent_id = result.stdout.strip()

    # Check if parent is trunk
    trunk_result = run([
        'jj', 'log',
        '-r', 'trunk()',
        '--no-graph',
        '-T', 'change_id.short()'
    ])
    trunk_id = trunk_result.stdout.strip()

    if parent_id == trunk_id:
        return None

    return parent_id


def get_bookmarks_for_change(change_id: str) -> List[str]:
    """Get all bookmarks pointing to a change."""
    result = run([
        'jj', 'log',
        '-r', change_id,
        '--no-graph',
        '-T', 'bookmarks'
    ])

    output = result.stdout.strip()
    if not output or output == '(empty)':
        return []

    # Parse bookmark list (format: "bookmark1 bookmark2 bookmark3")
    return [b.strip() for b in output.split() if b.strip()]


def bookmark_exists(bookmark: str) -> bool:
    """Check if a bookmark exists."""
    result = run(['jj', 'bookmark', 'list'], check=True)
    for line in result.stdout.split('\n'):
        if line.strip().startswith(bookmark + ':') or line.strip().startswith(bookmark + ' '):
            return True
    return False


# ============================================================================
# Bookmark Management
# ============================================================================

def generate_slug(description: str) -> str:
    """Generate a URL-friendly slug from the first line of description.

    Example: "Fix authentication bug" -> "fix-auth-bug"
    """
    title = description.split('\n')[0]

    # Convert to lowercase
    slug = title.lower()

    # Remove special characters, keep alphanumeric and spaces
    slug = re.sub(r'[^a-z0-9\s-]', '', slug)

    # Replace spaces and multiple hyphens with single hyphen
    slug = re.sub(r'[-\s]+', '-', slug)

    # Trim hyphens from ends
    slug = slug.strip('-')

    # Limit length (take first 5 words max)
    words = slug.split('-')[:5]
    slug = '-'.join(words)

    return slug or 'change'


def generate_bookmark_name(change: Change, username: str, date: str) -> str:
    """Generate bookmark name: username/date/slug-change_id."""
    slug = generate_slug(change.description)
    return f"{username}/{date}/{slug}-{change.change_id}"


def ensure_bookmark(change: Change, username: str, date: str) -> str:
    """Create bookmark if it doesn't exist, return bookmark name.

    If bookmark exists but points to different commit, move it to current commit.
    Also ensures the bookmark is tracked with the remote.
    """
    bookmark = generate_bookmark_name(change, username, date)

    if bookmark_exists(bookmark):
        # Move bookmark to current commit for this change (in case it's moved)
        run(['jj', 'bookmark', 'set', bookmark, '-r', change.change_id, '-B'])
    else:
        # Create new bookmark
        run(['jj', 'bookmark', 'create', bookmark, '-r', change.change_id])
        # Track bookmark with remote
        run(['jj', 'bookmark', 'track', bookmark, '--remote=origin'])

    return bookmark


# ============================================================================
# PR Operations
# ============================================================================

def format_pr_description(
    change: Change,
    all_changes: List[Change],
    username: str,
    change_to_pr: Dict[str, int]
) -> str:
    """Format PR description with stack information and cross-references."""
    description = change.description

    # Build stack information section
    stack_info = ["\n---\n", "**Stack Information:**"]

    # Find position in stack
    position = next((i + 1 for i, c in enumerate(all_changes) if c.change_id == change.change_id), 0)
    stack_info.append(f"- **Stack Position:** {position} of {len(all_changes)}")

    # Find all ancestor PRs (from trunk to current, excluding current)
    ancestor_prs = []
    current_id = change.change_id
    while True:
        parent_id = get_parent_change_id(current_id)
        if not parent_id:
            break
        if parent_id in change_to_pr:
            parent_change = next((c for c in all_changes if c.change_id == parent_id), None)
            if parent_change:
                ancestor_prs.append((change_to_pr[parent_id], parent_change.title))
        current_id = parent_id

    # Reverse so it goes from bottom to top
    ancestor_prs.reverse()

    # Find all descendant PRs (from current to top of stack, excluding current)
    descendant_prs = []
    for c in all_changes:
        # Check if this change is a descendant
        current_id = c.change_id
        while True:
            parent_id = get_parent_change_id(current_id)
            if not parent_id:
                break
            if parent_id == change.change_id:
                # This change is a descendant
                if c.change_id in change_to_pr:
                    descendant_prs.append((change_to_pr[c.change_id], c.title))
                break
            current_id = parent_id

    # List all PRs in stack (reversed order: top to bottom)
    if ancestor_prs or descendant_prs:
        stack_info.append("\n**Stack:**")

        # Show descendants (reversed, so furthest descendant first)
        for pr_num, title in reversed(descendant_prs):
            stack_info.append(f"- #{pr_num}: {title}")

        # Show current (this PR)
        if change.change_id in change_to_pr:
            stack_info.append(f"- **→ #{change_to_pr[change.change_id]}: {change.title}** (this PR)")
        else:
            stack_info.append(f"- **→ {change.title}** (this PR)")

        # Show ancestors (reversed, so immediate parent first)
        for pr_num, title in reversed(ancestor_prs):
            stack_info.append(f"- #{pr_num}: {title}")

    stack_info.append(f"\n**JJ Change ID:** `{change.change_id}`")
    stack_info.append("\n---")
    stack_info.append("_This PR is part of a stack managed by jj-stack._")

    return description + '\n'.join(stack_info)


def create_pr(
    bookmark: str,
    change: Change,
    base_branch: str,
    all_changes: List[Change],
    username: str,
    change_to_pr: Dict[str, int]
) -> int:
    """Create GitHub PR for change.

    Returns PR number.
    """
    title = change.title
    body = format_pr_description(change, all_changes, username, change_to_pr)

    result = run([
        'gh', 'pr', 'create',
        '-B', base_branch,
        '-H', bookmark,
        '-t', title,
        '-b', body
    ])

    # Extract PR number from output
    # Output format: "https://github.com/owner/repo/pull/123"
    match = re.search(r'/pull/(\d+)', result.stdout)
    if match:
        return int(match.group(1))

    # Fallback: query for PR by head branch
    pr_num = find_pr_for_change(change.change_id, username)
    if pr_num:
        return pr_num

    print(f"Warning: Could not determine PR number for {bookmark}", file=sys.stderr)
    return 0


def update_pr(
    pr_number: int,
    change: Change,
    base_branch: str,
    all_changes: List[Change],
    username: str,
    change_to_pr: Dict[str, int]
):
    """Update existing PR (title, base branch, and description)."""
    title = change.title
    body = format_pr_description(change, all_changes, username, change_to_pr)

    # Update title, base branch, and body in one call
    run([
        'gh', 'pr', 'edit', str(pr_number),
        '--title', title,
        '--base', base_branch,
        '--body', body
    ], check=False)


# ============================================================================
# Commands
# ============================================================================

def cmd_push(args):
    """Push entire stack to GitHub, creating/updating PRs."""
    username = get_github_username()
    changes = get_stack_changes()

    if not changes:
        print("No changes in stack.")
        return

    print(f"Found {len(changes)} change(s) in stack")

    date = datetime.now().strftime('%Y-%m-%d')
    change_to_bookmark = {}

    # First pass: create bookmarks and push them
    print("\nCreating bookmarks and pushing to GitHub...")
    for change in changes:
        bookmark = ensure_bookmark(change, username, date)
        change_to_bookmark[change.change_id] = bookmark
        print(f"  {change.change_id}: {bookmark}")

        # Push bookmark
        result = run(['jj', 'git', 'push', '--bookmark', bookmark], check=False)
        if result.returncode != 0:
            print(f"Warning: Failed to push bookmark {bookmark}", file=sys.stderr)

    # Second pass: create or update PRs
    print("\nCreating/updating PRs...")
    change_to_pr = {}

    # First, find all existing PRs
    for change in changes:
        pr_num = find_pr_for_change(change.change_id, username)
        if pr_num:
            change_to_pr[change.change_id] = pr_num

    # Now create/update PRs in order
    newly_created = []
    for change in changes:
        bookmark = change_to_bookmark[change.change_id]

        # Determine base branch
        parent_id = get_parent_change_id(change.change_id)
        if parent_id and parent_id in change_to_bookmark:
            base_branch = change_to_bookmark[parent_id]
        else:
            base_branch = "master"

        # Check if PR already exists
        pr_number = change_to_pr.get(change.change_id)

        if not pr_number:
            # Create new PR
            try:
                pr_number = create_pr(bookmark, change, base_branch, changes, username, change_to_pr)
                if pr_number:
                    change_to_pr[change.change_id] = pr_number
                    newly_created.append(change.change_id)
                    print(f"  ✓ Created PR #{pr_number}: {change.title}")
            except Exception as e:
                print(f"  ✗ Failed to create PR for {change.change_id}: {e}", file=sys.stderr)
        else:
            # Update existing PR
            try:
                update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                print(f"  ✓ Updated PR #{pr_number}: {change.title}")
            except Exception as e:
                print(f"  ✗ Failed to update PR #{pr_number}: {e}", file=sys.stderr)

    # Third pass: Update descriptions for newly created PRs to include links to each other
    if newly_created:
        print("\nUpdating PR cross-references...")
        for change in changes:
            if change.change_id in newly_created:
                pr_number = change_to_pr.get(change.change_id)
                if pr_number:
                    # Determine base branch
                    parent_id = get_parent_change_id(change.change_id)
                    if parent_id and parent_id in change_to_bookmark:
                        base_branch = change_to_bookmark[parent_id]
                    else:
                        base_branch = "master"

                    try:
                        update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                        print(f"  ✓ Updated PR #{pr_number} with full cross-references")
                    except Exception as e:
                        print(f"  ✗ Failed to update PR #{pr_number}: {e}", file=sys.stderr)

    print(f"\nStack pushed successfully! ({len(changes)} changes)")

    # Print GitHub API operation statistics
    print("\n" + "=" * 60)
    print("GitHub API Operation Statistics:")
    print("=" * 60)
    total_operations = 0
    for operation, count in sorted(GITHUB_OPERATION_COUNTS.items()):
        print(f"  {operation}: {count}")
        total_operations += count
    print("-" * 60)
    print(f"  Total GitHub API operations: {total_operations}")
    print("=" * 60)


def cmd_status(args):
    """Display status of current stack and PRs."""
    username = get_github_username()
    changes = get_stack_changes()

    print(f"Current Stack Status (GitHub user: {username})")
    print("=" * 60)

    if not changes:
        print("\nNo changes in stack.")
        return

    for i, change in enumerate(changes, 1):
        print(f"\n{i}. {change.title}")
        print(f"   Change ID: {change.change_id}")

        # Find bookmark for this change
        bookmarks = get_bookmarks_for_change(change.change_id)
        user_bookmarks = [b for b in bookmarks if b.startswith(f"{username}/")]
        if user_bookmarks:
            print(f"   Bookmark: {user_bookmarks[0]}")
        else:
            print(f"   Bookmark: Not created yet")

        # Find PR for this change
        pr_number = find_pr_for_change(change.change_id, username)

        if pr_number:
            try:
                pr_info = get_pr_info(pr_number)
                print(f"   PR: #{pr_number} ({pr_info['state']})")
                print(f"   URL: {pr_info['url']}")
            except Exception as e:
                print(f"   PR: #{pr_number} (error getting details: {e})")
        else:
            print(f"   PR: Not created yet")

    print("\n" + "=" * 60)
    print(f"Total: {len(changes)} change(s)")


def cmd_sync(args):
    """Sync stack with latest trunk and update PRs."""
    username = get_github_username()

    # 1. Fetch latest trunk
    print("Fetching latest trunk...")
    run(['jj', 'git', 'fetch'])

    # 2. Rebase stack
    print("Rebasing stack...")
    result = run(['jj', 'rebase', '-d', 'trunk()'], check=False)
    if result.returncode != 0:
        print("Error: Rebase failed. Resolve conflicts and run sync again.", file=sys.stderr)
        sys.exit(1)

    # 3. Get all changes
    changes = get_stack_changes()

    if not changes:
        print("No changes in stack.")
        return

    # 4. Update bookmarks to point to rebased commits
    print("Updating bookmarks...")
    for change in changes:
        bookmarks = get_bookmarks_for_change(change.change_id)
        for bookmark in bookmarks:
            if bookmark.startswith(f"{username}/"):
                # Move bookmark to current commit for this change
                run(['jj', 'bookmark', 'set', bookmark, '-r', change.change_id, '-B'])

    # 5. Force-push updated bookmarks
    print("Force-pushing updated bookmarks...")
    for change in changes:
        bookmarks = get_bookmarks_for_change(change.change_id)
        for bookmark in bookmarks:
            if bookmark.startswith(f"{username}/"):
                result = run(['jj', 'git', 'push', '--bookmark', bookmark], check=False)
                if result.returncode != 0:
                    print(f"Warning: Failed to push bookmark {bookmark}", file=sys.stderr)

    # 6. Update PRs
    print("Updating PRs...")

    date = datetime.now().strftime('%Y-%m-%d')
    change_to_bookmark = {}
    change_to_pr = {}

    # Build mappings
    for change in changes:
        bookmarks = get_bookmarks_for_change(change.change_id)
        for bookmark in bookmarks:
            if bookmark.startswith(f"{username}/"):
                change_to_bookmark[change.change_id] = bookmark
                break

        pr_num = find_pr_for_change(change.change_id, username)
        if pr_num:
            change_to_pr[change.change_id] = pr_num

    # Update each PR
    for change in changes:
        pr_number = change_to_pr.get(change.change_id)
        if pr_number:
            # Determine correct base branch
            parent_id = get_parent_change_id(change.change_id)
            if parent_id and parent_id in change_to_bookmark:
                base_branch = change_to_bookmark[parent_id]
            else:
                base_branch = "master"

            try:
                update_pr(pr_number, change, base_branch, changes, username, change_to_pr)
                print(f"  ✓ Updated PR #{pr_number}")
            except Exception as e:
                print(f"  ✗ Failed to update PR #{pr_number}: {e}", file=sys.stderr)

    print("\nStack synced successfully!")


def cmd_cleanup(args):
    """Remove bookmarks for merged/closed PRs."""
    username = get_github_username()

    # Get all bookmarks matching our pattern
    result = run(['jj', 'bookmark', 'list'])
    bookmarks = []
    for line in result.stdout.split('\n'):
        line = line.strip()
        if not line:
            continue
        # Parse bookmark name (format: "bookmark: commit_id")
        parts = line.split(':', 1)
        if parts and parts[0].strip().startswith(f"{username}/"):
            bookmark = parts[0].strip()
            bookmarks.append(bookmark)

    if not bookmarks:
        print(f"No bookmarks found for user {username}")
        return

    print(f"Found {len(bookmarks)} bookmark(s) for {username}")

    cleaned = 0
    for bookmark in bookmarks:
        # Extract change ID from bookmark name
        parts = bookmark.split('-')
        if not parts:
            continue
        change_id = parts[-1]

        # Find PR for this change (search all states)
        pr_number = find_pr_for_change(change_id, username, state='all')

        if pr_number:
            pr_state = get_pr_state(pr_number)

            if pr_state in ['MERGED', 'CLOSED']:
                print(f"Cleaning up bookmark {bookmark} (PR #{pr_number} is {pr_state})")

                # Delete bookmark locally
                run(['jj', 'bookmark', 'delete', bookmark])

                cleaned += 1

    # Push all deletions to remote in one command
    if cleaned > 0:
        print("Pushing bookmark deletions to remote...")
        run(['jj', 'git', 'push', '--deleted'], check=False)

    print(f"\nCleaned up {cleaned} bookmark(s)")


def cmd_list(args):
    """List all changes in current stack with metadata."""
    changes = get_stack_changes()

    if not changes:
        print("No changes in stack.")
        return

    print(f"Stack Changes (trunk()..@):")
    print("=" * 60)

    for i, change in enumerate(changes, 1):
        print(f"\n{i}. {change.title}")
        print(f"   Change ID: {change.change_id}")
        print(f"   Commit ID: {change.commit_id}")

        parent_id = get_parent_change_id(change.change_id)
        if parent_id:
            print(f"   Parent: {parent_id}")
        else:
            print(f"   Parent: trunk")

        bookmarks = get_bookmarks_for_change(change.change_id)
        if bookmarks:
            print(f"   Bookmarks: {', '.join(bookmarks)}")

    print("\n" + "=" * 60)
    print(f"Total: {len(changes)} change(s)")


# ============================================================================
# Main
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Automate pushing stacks of Jujutsu changes to GitHub as pull requests."
    )

    subparsers = parser.add_subparsers(dest='command', help='Subcommands')

    # push command
    push_parser = subparsers.add_parser(
        'push',
        help='Push current stack to GitHub, creating/updating PRs'
    )

    # status command
    status_parser = subparsers.add_parser(
        'status',
        help='Show status of current stack and associated PRs'
    )

    # sync command
    sync_parser = subparsers.add_parser(
        'sync',
        help='Fetch latest trunk, rebase stack, update PRs'
    )

    # list command
    list_parser = subparsers.add_parser(
        'list',
        help='List all changes in current stack with metadata'
    )

    # cleanup command
    cleanup_parser = subparsers.add_parser(
        'cleanup',
        help='Remove bookmarks for merged/closed PRs'
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Check prerequisites
    check_prerequisites()

    # Dispatch to command handler
    if args.command == 'push':
        cmd_push(args)
    elif args.command == 'status':
        cmd_status(args)
    elif args.command == 'sync':
        cmd_sync(args)
    elif args.command == 'list':
        cmd_list(args)
    elif args.command == 'cleanup':
        cmd_cleanup(args)
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == '__main__':
    main()
